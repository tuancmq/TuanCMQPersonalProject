using LibGit2Sharp;
using LibGit2Sharp.Handlers;
using Microsoft.Extensions.Configuration;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

// ====================================================================================
// C·∫¢I TI·∫æN 1: S·ª¨A L·ªñI FONT TI·∫æNG VI·ªÜT TR√äN CONSOLE
// ====================================================================================
Console.OutputEncoding = Encoding.UTF8;
// ====================================================================================


// ====================================================================================
// KH·ªûI T·∫†O V√Ä ƒê·ªåC C·∫§U H√åNH T·ª™ appsettings.json
// ====================================================================================
var builder = new ConfigurationBuilder()
    .SetBasePath(AppContext.BaseDirectory)
    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);

IConfiguration config = builder.Build();

var gitLabUrl = config["GitLab:Url"];
// var groupId = config["GitLab:GroupId"]; // THAY ƒê·ªîI 1: X√≥a d√≤ng n√†y
var gitLabToken = config["GitLab:Token"];

// ƒê·ªçc c·∫•u h√¨nh chung
var syncType = Enum.Parse<SyncType>(config["SyncOptions:SyncType"] ?? "ONE_FOLDER");
var maxConcurrentTasks = int.Parse(config["SyncOptions:MaxConcurrentTasks"] ?? "8");

// ƒê·ªçc tham s·ªë m√¥i tr∆∞·ªùng t·ª´ d√≤ng l·ªánh (command line)
if (args.Length == 0)
{
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine("‚ùå L·ªñI: Vui l√≤ng cung c·∫•p t√™n m√¥i tr∆∞·ªùng.");
    Console.ResetColor();
    Console.WriteLine("üëâ V√≠ d·ª•: gitsyncv3 sit");
    return;
}
var environmentKey = args[0];

// THAY ƒê·ªîI 2: ƒê·ªçc c·∫•u h√¨nh t·ª´ section m√¥i tr∆∞·ªùng c·ª• th·ªÉ
var envSection = config.GetSection($"Environments:{environmentKey}");
var branchName = envSection["BranchName"];
var targetPath = envSection["TargetPath"];
var groupId = envSection["GroupId"]; // ƒê·ªçc GroupId t·ª´ ƒë√¢y

// Ki·ªÉm tra c·∫•u h√¨nh c√≥ t·ªìn t·∫°i kh√¥ng
if (string.IsNullOrEmpty(branchName) || string.IsNullOrEmpty(targetPath) || string.IsNullOrEmpty(groupId))
{
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine($"‚ùå L·ªñI: C·∫•u h√¨nh ch∆∞a ƒë·∫ßy ƒë·ªß (BranchName, TargetPath, GroupId) cho m√¥i tr∆∞·ªùng '{environmentKey}'.");
    var availableEnvs = config.GetSection("Environments").GetChildren().Select(c => c.Key);
    Console.ResetColor();
    Console.WriteLine($"C√°c m√¥i tr∆∞·ªùng c√≥ s·∫µn: {string.Join(", ", availableEnvs)}");
    return;
}

// THAY ƒê·ªîI 3: C·∫≠p nh·∫≠t l·∫°i logic ki·ªÉm tra c·∫•u h√¨nh GitLab chung
if (string.IsNullOrEmpty(gitLabUrl) || string.IsNullOrEmpty(gitLabToken))
{
    Console.WriteLine("‚ùå L·ªñI NGHI√äM TR·ªåNG: Thi·∫øu c·∫•u h√¨nh GitLab (Url, Token) trong appsettings.json.");
    return;
}
// ====================================================================================

var stopwatch = Stopwatch.StartNew();
Console.WriteLine("üöÄ B·∫Øt ƒë·∫ßu qu√° tr√¨nh ƒë·ªìng b·ªô GitSync...");
// Hi·ªÉn th·ªã th√¥ng tin m√¥i tr∆∞·ªùng ƒëang ch·∫°y
Console.WriteLine($"M√¥i tr∆∞·ªùng: {environmentKey.ToUpper()}");
Console.WriteLine($"GitLab Group ID: {groupId}"); // <-- Th√™m d√≤ng n√†y ƒë·ªÉ x√°c nh·∫≠n Group ID
Console.WriteLine($"Ki·ªÉu ƒë·ªìng b·ªô: {syncType}");
Console.WriteLine($"Th∆∞ m·ª•c ƒë√≠ch: {targetPath}");
Console.WriteLine($"Nh√°nh (Branch): {branchName}");
Console.WriteLine("--------------------------------------------------");


Directory.CreateDirectory(targetPath);

var processingResults = new ConcurrentBag<ProcessResult>();

using var client = new HttpClient { BaseAddress = new Uri(gitLabUrl) };
client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", gitLabToken);
client.DefaultRequestHeaders.Add("User-Agent", "GitSyncTool/5.0");

try
{
    Console.WriteLine($"üîç Waiting for GitLab... ƒêang l·∫•y danh s√°ch t·∫•t c·∫£ repositories t·ª´ Group ID: {groupId}...");
    var allRepos = await GetAllRepositoriesAsync(client, groupId); // groupId gi·ªù l√† bi·∫øn c·ª•c b·ªô
    if (!allRepos.Any())
    {
        Console.WriteLine("Kh√¥ng t√¨m th·∫•y repository n√†o.");
        return;
    }

    Console.WriteLine($"‚úÖ T√¨m th·∫•y {allRepos.Count} repositories. B·∫Øt ƒë·∫ßu x·ª≠ l√Ω...");
    Console.WriteLine();

    using var semaphore = new SemaphoreSlim(maxConcurrentTasks);
    var processingTasks = allRepos.Select(async repo =>
    {
        await semaphore.WaitAsync();
        try
        {
            await CloneOrPullRepositoryAsync(repo);
        }
        finally
        {
            semaphore.Release();
        }
    });
    await Task.WhenAll(processingTasks);
}
catch (Exception ex)
{
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine($"M·ªôt l·ªói nghi√™m tr·ªçng kh√¥ng mong mu·ªën ƒë√£ x·∫£y ra: {ex.Message}");
    Console.ResetColor();
    processingResults.Add(new ProcessResult("FATAL_ERROR", ProcessStatus.Failed, ex.ToString()));
}
finally
{
    stopwatch.Stop();
    DisplaySummaryTable(processingResults.ToList());
    Console.WriteLine("--------------------------------------------------");
    Console.WriteLine($"üéâ Qu√° tr√¨nh ho√†n t·∫•t.");
    Console.WriteLine($"‚è± T·ªïng th·ªùi gian th·ª±c thi: {stopwatch.Elapsed.TotalSeconds:F2} gi√¢y.");
}

// C√°c h√†m c√≤n l·∫°i (GetAllRepositoriesAsync, CloneOrPullRepositoryAsync, DisplaySummaryTable, enums, record) kh√¥ng c·∫ßn thay ƒë·ªïi.

async Task<List<JObject>> GetAllRepositoriesAsync(HttpClient httpClient, string grpId)
{
    var repos = new List<JObject>();
    var page = 1;
    while (true)
    {
        var requestUri = $"/api/v4/groups/{grpId}/projects?per_page=100&page={page}&include_subgroups=true&with_shared=false&archived=false";
        var response = await httpClient.GetAsync(requestUri);
        response.EnsureSuccessStatusCode();
        var pageRepos = JArray.Parse(await response.Content.ReadAsStringAsync());
        if (pageRepos.Count == 0) break;
        repos.AddRange(pageRepos.Cast<JObject>());
        page++;
    }
    return repos;
}

Task CloneOrPullRepositoryAsync(JObject repoInfo)
{
    return Task.Run(() =>
    {
        string repoUrl = repoInfo["http_url_to_repo"]!.ToString();
        string repoPathWithNamespace = repoInfo["path_with_namespace"]!.ToString();

        string localRepoPath;
        switch (syncType)
        {
            case SyncType.GITLAB_FOLDER:
                localRepoPath = Path.Combine(targetPath, repoPathWithNamespace);
                break;
            case SyncType.ONE_FOLDER:
            default:
                localRepoPath = Path.Combine(targetPath, repoInfo["path"]!.ToString());
                break;
        }

        Directory.CreateDirectory(Path.GetDirectoryName(localRepoPath)!);

        var credentialsHandler = new CredentialsHandler((url, user, cred) => new UsernamePasswordCredentials { Username = "oauth2", Password = gitLabToken });
        var signature = new Signature("GitSyncTool", "gitsync@tool.com", DateTimeOffset.Now);

        try
        {
            if (Repository.IsValid(localRepoPath))
            {
                using var repo = new Repository(localRepoPath);

                var status = repo.RetrieveStatus();
                if (status.IsDirty)
                {
                    string message = "Skipped: Uncommitted changes detected.";
                    Console.ForegroundColor = ConsoleColor.DarkYellow;
                    Console.WriteLine($"‚ö†Ô∏è  B·ªè qua '{repoPathWithNamespace}': Ph√°t hi·ªán c√≥ thay ƒë·ªïi ch∆∞a ƒë∆∞·ª£c commit.");
                    Console.ResetColor();
                    processingResults.Add(new ProcessResult(repoPathWithNamespace, ProcessStatus.LocalChanges, message));
                    return;
                }

                if (repo.Head.TrackingDetails != null && repo.Head.TrackingDetails.AheadBy > 0)
                {
                    string message = $"Skipped: {repo.Head.TrackingDetails.AheadBy} unpushed commit(s) detected.";
                    Console.ForegroundColor = ConsoleColor.DarkYellow;
                    Console.WriteLine($"‚ö†Ô∏è  B·ªè qua '{repoPathWithNamespace}': Ph√°t hi·ªán {repo.Head.TrackingDetails.AheadBy} commit ch∆∞a ƒë∆∞·ª£c push.");
                    Console.ResetColor();
                    processingResults.Add(new ProcessResult(repoPathWithNamespace, ProcessStatus.LocalChanges, message));
                    return;
                }

                Console.WriteLine($"üîÑ ƒêang ki·ªÉm tra c·∫≠p nh·∫≠t cho '{repoPathWithNamespace}'...");

                var pullOptions = new PullOptions
                {
                    FetchOptions = new FetchOptions { CredentialsProvider = credentialsHandler, Prune = true },
                    MergeOptions = new MergeOptions()
                };

                var result = Commands.Pull(repo, signature, pullOptions);

                switch (result.Status)
                {
                    case MergeStatus.UpToDate:
                        Console.WriteLine($"üëç '{repoPathWithNamespace}' ƒë√£ ·ªü phi√™n b·∫£n m·ªõi nh·∫•t.");
                        processingResults.Add(new ProcessResult(repoPathWithNamespace, ProcessStatus.UpToDate, "Already up-to-date."));
                        break;

                    case MergeStatus.FastForward:
                    case MergeStatus.NonFastForward:
                        var successDetails = $"Pulled successfully. New commit: {result.Commit.Id.ToString(7)}";
                        Console.WriteLine($"‚úÖ ƒê√£ k√©o (pull) th√†nh c√¥ng '{repoPathWithNamespace}'.");
                        processingResults.Add(new ProcessResult(repoPathWithNamespace, ProcessStatus.Pulled, successDetails));
                        break;

                    case MergeStatus.Conflicts:
                        string conflictMessage = "Merge conflict detected. Repo has been reset and skipped.";
                        Console.ForegroundColor = ConsoleColor.Magenta;
                        Console.WriteLine($"‚ùóÔ∏è XUNG ƒê·ªòT (CONFLICT) t·∫°i '{repoPathWithNamespace}'. ƒêang reset v√† b·ªè qua.");
                        Console.ResetColor();
                        repo.Reset(ResetMode.Hard, repo.Head.Tip);
                        processingResults.Add(new ProcessResult(repoPathWithNamespace, ProcessStatus.Conflict, conflictMessage));
                        break;

                    default:
                        string otherError = $"Pull failed with unexpected status: {result.Status}";
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.WriteLine($"‚ùå Th·∫•t b·∫°i '{repoPathWithNamespace}': {otherError}");
                        Console.ResetColor();
                        processingResults.Add(new ProcessResult(repoPathWithNamespace, ProcessStatus.Failed, otherError));
                        break;
                }
            }
            else
            {
                Console.WriteLine($"üì• ƒêang nh√¢n b·∫£n (clone) '{repoPathWithNamespace}' (nh√°nh '{branchName}')...");
                var cloneOptions = new CloneOptions
                {
                    BranchName = branchName,
                    FetchOptions = { CredentialsProvider = credentialsHandler }
                };

                string resultPath = Repository.Clone(repoUrl, localRepoPath, cloneOptions);
                Console.WriteLine($"‚úÖ ƒê√£ nh√¢n b·∫£n (clone) th√†nh c√¥ng '{repoPathWithNamespace}'.");
                processingResults.Add(new ProcessResult(repoPathWithNamespace, ProcessStatus.Cloned, $"Cloned into {resultPath}"));
            }
        }
        catch (LibGit2Sharp.NotFoundException)
        {
            string message = $"Skipped: Branch '{branchName}' not found.";
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine($"‚ö†Ô∏è  B·ªè qua '{repoPathWithNamespace}': Kh√¥ng t√¨m th·∫•y nh√°nh (branch) '{branchName}'.");
            Console.ResetColor();
            processingResults.Add(new ProcessResult(repoPathWithNamespace, ProcessStatus.Skipped, message));
        }
        catch (Exception ex)
        {
            string errorMessage = $"FAILED: {ex.GetType().Name} - {ex.Message.Trim()}";
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"‚ùå Th·∫•t b·∫°i '{repoPathWithNamespace}': {ex.Message.Trim()}");
            Console.ResetColor();
            processingResults.Add(new ProcessResult(repoPathWithNamespace, ProcessStatus.Failed, ex.Message.Trim()));
        }
    });
}

void DisplaySummaryTable(List<ProcessResult> results)
{
    if (!results.Any()) return;

    var sortedResults = results.OrderBy(r => r.RepositoryPath).ToList();

    Console.WriteLine();
    Console.WriteLine("üìä B·∫¢NG T·ªîNG H·ª¢P K·∫æT QU·∫¢");
    Console.WriteLine("========================");

    int repoPathWidth = sortedResults.Select(r => r.RepositoryPath.Length).DefaultIfEmpty(10).Max() + 2;
    int statusWidth = sortedResults.Select(r => r.Status.ToString().Length).DefaultIfEmpty(10).Max() + 2;

    string header = $"| {"Repository".PadRight(repoPathWidth)} | {"Status".PadRight(statusWidth)} | Details";
    Console.WriteLine(header);
    Console.WriteLine($"|-{new string('-', repoPathWidth)}-|-{new string('-', statusWidth)}-|--------");

    foreach (var result in sortedResults)
    {
        Console.Write($"| {result.RepositoryPath.PadRight(repoPathWidth)} ");
        Console.Write($"| ");

        switch (result.Status)
        {
            case ProcessStatus.Cloned:
            case ProcessStatus.Pulled:
                Console.ForegroundColor = ConsoleColor.Green;
                break;
            case ProcessStatus.UpToDate:
                Console.ForegroundColor = ConsoleColor.Cyan;
                break;
            case ProcessStatus.Conflict:
                Console.ForegroundColor = ConsoleColor.Magenta;
                break;
            case ProcessStatus.Skipped:
                Console.ForegroundColor = ConsoleColor.Yellow;
                break;
            case ProcessStatus.LocalChanges:
                Console.ForegroundColor = ConsoleColor.DarkYellow;
                break;
            case ProcessStatus.Failed:
                Console.ForegroundColor = ConsoleColor.Red;
                break;
        }
        Console.Write($"{result.Status.ToString().PadRight(statusWidth)}");
        Console.ResetColor();
        Console.WriteLine($" | {result.Details}");
    }

    Console.WriteLine();
    Console.WriteLine("üìà Th·ªëng k√™:");
    var summary = sortedResults.GroupBy(r => r.Status)
                                     .Select(g => new { Status = g.Key, Count = g.Count() })
                                     .OrderBy(x => x.Status);

    foreach (var item in summary)
    {
        Console.WriteLine($"\t- {item.Status}: {item.Count}");
    }

    var conflictRepos = sortedResults.Where(r => r.Status == ProcessStatus.Conflict).ToList();
    if (conflictRepos.Any())
    {
        Console.WriteLine();
        Console.ForegroundColor = ConsoleColor.Magenta;
        Console.WriteLine("‚ùóÔ∏è DANH S√ÅCH REPO B·ªä XUNG ƒê·ªòT (CONFLICT)");
        Console.ResetColor();
        Console.WriteLine("------------------------------------------");
        foreach (var repo in conflictRepos)
        {
            Console.WriteLine($"- {repo.RepositoryPath}");
        }
    }

    var localChangeRepos = sortedResults.Where(r => r.Status == ProcessStatus.LocalChanges).ToList();
    if (localChangeRepos.Any())
    {
        Console.WriteLine();
        Console.ForegroundColor = ConsoleColor.DarkYellow;
        Console.WriteLine("‚ö†Ô∏è  DANH S√ÅCH REPO C·∫¶N L∆ØU √ù (C√ì THAY ƒê·ªîI CH∆ØA COMMIT/PUSH)");
        Console.ResetColor();
        Console.WriteLine("-------------------------------------------------------------");
        foreach (var repo in localChangeRepos)
        {
            Console.WriteLine($"- {repo.RepositoryPath} ({repo.Details})");
        }
    }
}


public enum SyncType { ONE_FOLDER, GITLAB_FOLDER }
public enum ProcessStatus { Cloned, Pulled, UpToDate, Skipped, Failed, Conflict, LocalChanges }
public record ProcessResult(string RepositoryPath, ProcessStatus Status, string Details);
